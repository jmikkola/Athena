// Framework

mod routing {
    pub macro build(definitions) {
    }

    pub macro aliasFor(s Symbol) {
    }

    pub data UrlPath {
        path String
        query Map<String, String>
    }

    data PatternPart =
        ExactString { string String }
        Pattern { name Maybe<String>, pattern Re }

    impl PatternPart {
        fn render(ExactString{s},  _)      = Just(s)
        fn render(Pattern{name, }, pieces) = pieces.lookup(name)

        fn matches(ExactString{s}, part) = s == part
        fn matches(Pattern{_, re}, part) = re.matches(part)
    }

    // Define it here for being able to reuse its memory
    let emptyPattern = ExactString("")

    type PatternsByName = Map<Symbol, List<PatternPart>>

    fn buildUrl(patternParts, pieces) {
        return patternParts
            .mapM(fn (part) = part.render(pieces))
            .join("/")
    }

    impl PatternsByName {
        fn reverse(self, symbol, pieces) =
            self.lookup(symbol).then(fn (patternParts) = buildUrl(patternParts, pieces))
    }

    struct Route =
        LeafRoute { routeName Symbol }
        NestedRoute { routes Map<PatternPart, Route> }

    impl Route {
        fn route(LeafRoute(name), []) = Just(Match(name, {}))
        fn route(LeafRoute(name), _)  = Nothing
        fn route(NestedRoute{routes}, []) = Nothing
        fn route(NestedRoute{routes}, [part:rest]) {
            for pattern, suboute in routes {
                if pattern.match(part) {
                    let result = subroute.route(rest)
                    ifMatch Just(m) = result {
                         // TODO: add in any matched param
                        return result
                    }
                }
            }
            return Nothing
        }
    }

    pub struct Routes {
        root    Route
        byName  PatternsByName
    }

    pub struct Match {
        name   Symbol
        pieces Map<String, String>
    }

    impl Routes {
        pub fn reverse(self, name Symbol, pieces Map<String, String>) Maybe<String> =
            self.byName.reverse(name, pieces)

        pub fn route(urlPath String) Maybe<Match> =
            self.root.route(urlPath.split("/"))
    }
}


// Route definitions

let routes = routing.build {
    ""        :home
    "task"    {
        ""                 :task
        ":id:[a-z0-9]{16}" :task_view
        "search"           :task_search
        "old"              :task_old
    }
    "about"   :about
    "welcome" routing.aliasFor(:signup)
    "signup"  :signup
    "login"   :login
    "logout"  :logout
}

type TaskId = String

data Task {
    id TaskId
    text String
    dateAdded Date
}

fn taskRoute(task Task) UrlPath =
    routes.reverse(:task_view, {"id" str(task.id)})

@test
fn testTaskRoute() {
    let expected = Match{name = :task_view, parts = {"id": "testid"})
    assertEqual(Just(expected), routes.route("/task/testid/"))
}
