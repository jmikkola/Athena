

<file> ::= <?module> <declarations>?

<?module> ::= <module_decl> <;> | ""
<module_decl> ::= <kwd_mod> <s+> <module_name>
<module_name> ::= /[a-z][a-zA-Z0-9_]+/
<kwd_mod> ::= "module"

<declarations> ::= <decl> <;> <declarations>> | <decl>
<decl> ::= <constant> | <function> | <type>

<constant> ::= <kwd_const> <s+> <valueName> <s+> <=> <_> <expression>
<kwd_const> ::= "const"

<valueName> ::= /[a-z][a-zA-Z9-0_?]*/

<function> ::= <kwd_fn> <s+> <valueName> <argList> <fn_body>
<argList> ::= "(" <_>? <arguments>? <_>? ")"
<arguments> ::= <argument> <_>? "," <_> <arguments> | <argument>
<argument> ::= <valueName> (<s+> <type_def>)?
<fn_body> ::= <short_fn_body> | <long_fn_body>
<sort_fn_body> ::= <_> <=> <_> <expression>
<long_fn_body> ::= <s+> <code_block>
<kwd_fn> ::= "fn"

<code_block> ::= "{" <_>? <statements>? <_>? "}"

<type_def> ::= <typeName> ("[" <_>? <typeArgs> <_>? "]")?
<typeArgs> ::= <typeArg> <s+>? "," <s+> <typeArgs> | <typeArg>
<typeArg> ::= <typeVar> | <type_def>
<typeVar> ::= /[a-z][a-z0-9]*/
<typeName> ::= /[A-Z][a-z0-9]*/

<statements> ::= <stmt> <;> <statements> | <stmt>
<stmt> ::= <expression> | <assignment_stmt> | <return_stmt> | <if_stmt> | <while_stmt> | <for_stmt>

<assignment_stmt> ::= <let_kwd> <_> <valueName> <s+> <=> <_> <expression>
<let_kwd> = "let"

<return_stmt> ::= <return_kwd> <s+> <expression>

-- TOOD: the whitespace handling here is a mess
<if_stmt> ::= <if_kwd> <s+> <expression> <s+> <code_block> <_>? <else_if_stmt> <_>? <else_stmt>
<else_if_stmt> ::= "" | <else_kwd> <s+> <if_kwd> <s+> <expression> <s+> <code_block> <else_if_stmt>
<else_stmt> ::= "" | <else_kwd> <s+> <code_block>
<if_kwd> ::= "if"
<else_kwd> ::= "else"

<while_stmt> ::= <while_kwd> <s+> <expression> <s+> <code_block>
<while_kwd> ::= "while"

<for_stmt> ::= <for_kwd> <s+> <variable> <s+> <in_kwd> <s+> <expression> <code_block>
<for_kwd> ::= "for"
<in_kwd> ::= "in"

<expressions> ::= <expression> <;> <expressions> | <expression>
<expression> ::= <literal> | <variable> | <paren_expr> | <unary_expr> | <binary_expr> | <fn_call> | <lambda_expr> | <list_expr> | <if_expr> | <match_expr>

<expression_block> ::= "{" <_>? <expression> <_>? "}"

<variable> ::= <valueName>

<paren_expr> ::= "(" <paren_body> ")"
<paren_body> ::= <tuple_vals> | <expression> | ""
<tuple_vals> ::= <tuple_val> <_>? <tuple_vals> | <tuple_val>
<tuple_val> ::= <expression> <s+> ","

<unary_expr> ::= <unary_op> <short_expr>
<unary_op> ::= "-" | "~" | "!"
<short_expr> ::= <literal> | <variable> | <paren_expr> | <fn_call> | <list_expr>

-- TODO: doesn't handle precedence
<binary_expr> ::= <expression> <_> <binary_op> <_> <expression>
<binary_op> ::= "+" | "-" | "*" | "/" | "and" | "or" | "xor" | "^" | "%" | "."

<fn_call> ::= <fn_name> "(" <_>? (<arg_values> <_>?)? ")"
<fn_name> ::= <valueName>
<arg_values> ::= <expression> <s+> "," <_> <arg_values> | <expression>

<lambda_expr> ::= <fn_kwd> " " (<fn_name> <s+>)? <argList> <fn_body>

-- TODO: add else if
<if_expr> ::= <if_kwd> <s+> <expression> <s+> <expression_block> <s+> <else_kwd> <s+> <expression_block>

<match_expr> ::= <match_kwd> <s+> <expression> <s+> "{" <_>? <match_cases> <_>? "}"
<match_cases> ::= <match_case> <;> <match_cases> | <match_case>
<match_case> ::= <matcher> <s+> "=>" <_> <code_block>
<match_kwd> ::= "match"

<matcher> ::= <literal> | <struct_matcher>
<struct_matcher> ::= <typeName> <struct_arg_matcher>?
<struct_arg_matcher> ::= "(" <_>? <inner_matcher> <_>? ")" | "{" <_> <field_matchers>  <_> "}"
<field_matchers> ::= <field_matcher> <_>? "," <_> <field_matchers> | <field_matcher>
<field_matcher> ::= <field_name> <s+>? <=> <_>? <inner_matcher>
<field_name> ::= <valueName>
<inner_matcher> ::= <variable> | <matcher>

<literal> ::= <lit_num> | <lit_string> | <lit_struct>

<lit_num> ::= <digits> <floating_part>? | <hex_num> | <octal_num> | <binary_num>
<digits> ::= <digit> <_digits> | <digit>
-- Allow separating numbers like 10_000_000:
<_digits> ::= "_" <digits> | <digits>
<floating_part> ::= "." <digits>? <exponent>?
<exponent> ::= "e" <digit>+
<digit> ::= /[0-9]/
<hex_num> ::= "0x" <hexit>+
<hexit> ::= /[0-9a-f]/
<octal_num> ::= "0o" <octit>+
<octit> ::= /[0-7]/
<binary_num> ::= "0b" <bit>*
<bit> ::= "0" | "1"

-- The grammar itself doesn't care about escape codes like \n
<lit_string> ::= <'_str> | <"_str> | <"""_str>
<'_str> ::= "'" <'_chr>* "'"
<'_chr> ::= /[^']/ | "\'"
<"_str> ::= """ <"_chr>* """
<"_chr> ::= /[^"]/ | "\""
<"""_str> ::= """"" <"""_chrs>? """""
-- Allow " or "" but not """ inside the string:
<"""_chrs> ::= <"_chr> <"""_chrs> | """ <"_chr> <"""_chrs> | """" <"_chr> <"""_chrs>

<lit_struct> ::= <typeName> <struct_body>
<struct_body> ::= "" | "(" <_>? <expression> <_>? ")" | "{" <_> <field_values> <_> "}"
<field_values> ::= <field_value> <s+>? "," <_>? <field_values> | <field_value>
<field_value> ::= <field_name> ":" <_> <expression>

-- TODO: add interface types
<type> ::= <type_kwd> <s+> <typeName> <s+> <=> <_> <type_definition>
<type_definition> ::= <data_type> | <alias_type> | <new_type>
-- TODO: add type variables
<data_type> ::= <struct_kwd> <s+> "{" <_> <struct_fields> <_> "}"
<struct_fields> ::= <struct_field> <;> <struct_fields> | <struct_field>
<struct_field> ::= <field_name> <s+> <type_def>

<alias_type> ::= <alias_kwd> <s+> <type_def>
<new_type> ::= <newtype_kwd> <s+> <type_def>

<type_kwd> ::= "type"
<struct_kwd> ::= "struct"
<alias_kwd> ::= "alias"
<newtype_kwd> ::= "newtype"

<=> = "="
-- <;> Means end of statement. It can be either a semicolon or a newline.
<;> ::= <_>? ";" <_>? | <_>? "\n" <_>?

-- <_> Means whitespace that can include a comment
<_> ::= <s+> <_>? | <block_comment> <_>? | <inline_commeent>
<s+> ::= /\s+/

<block_comment> ::= "/*" (not "*/")* "*/"
<inline_commeent> ::= "//" (not "\n")*